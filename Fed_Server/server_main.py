import os
# Konsolda tensorflow ile ilgili gereksiz bir uyarı metninin kapatılması için kullanılır.
os.environ['TF_ENABLE_ONEDNN_OPTS'] = '0'

import ssl
import socket
from models.model import FNN_BC, FNN_MC, LSTM_BC, LSTM_MC
from other import info_load, info_update, encrypt_file, remove_files
from server_functions import handle_client, model_update, print_global_round

# Temel ayarlar, server_main.json dosyasından yüklenir.
info = info_load()
info['round_num'] = 1
info['local_models'] = []
info["loss"] = info['losses'][info['class_type']]
info["csv_file"] = info['csv_files'][info['class_type']]
# Başlangıç ayarları yeniden server_main.json dosyasına kaydedilir.
info_update(info)

# Önceki kullanımlardan kalan model dosyaları yeni çalıştırmada silinir.
remove_files('models/global')
remove_files('models/local_models')

global_model = None

# arc_type = 0 ise FNN mimarisi kullanılır.
if info['arc_type'] == 0:
    if info['class_type'] == 0:
        global_model = FNN_BC().build()
    else:
        global_model = FNN_MC().build()

# arc_type = 1 ise LSTM mimarisi kullanılır.
else:
    if info['class_type'] == 0:
        global_model = LSTM_BC().build()
    else:
        global_model = LSTM_MC().build()

# Başlangıç modelin katsayıları
# server_main.json dosyasında global_model_prefix ayarında
# belirtilen dizindeki dosyaya kaydedilir.
global_model.save_weights(f"{info['global_model_prefix']}")
# başlangıç modelin katsayılarının bulunduğu dosya
# global_model_enc_prefix'te belirtilen dizinde şifrelenir.
encrypt_file(f"{info['global_model_prefix']}", f"{info['global_model_enc_prefix']}")

# SSL bağlantı için hazırlıklar
context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
context.load_cert_chain(certfile=info["certfile"], keyfile=info["keyfile"])

if info['arc_type'] == 0:
    mimari = "Feed-Forward Neural Network"
else:
    mimari = "Long Short-Term Memory"

# SSL bağlantısı kurulur ve istekler dinlenmeye başlanur.
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
    sock.bind((info["server_host"], info["server_port"]))
    sock.listen(64) # 64 sayısı, aynı anda organize edilebilecek bağlantı sayısıdır.

    print("--------------------------")
    print(f" Federe Öğrenme Sunucusu başlatıldı!")
    print(f" Host: {info['server_host']} | Port: {info['server_port']}")
    print("--------------------------")
    print(f" Mimari: {mimari}")
    print(f" Sınıflandırma: {info['types'][info['class_type']].capitalize()}")
    print(f" Kullanıcı Kapasitesi: {info['users']}")
    print_global_round()
    print("--------------------------")

    while True:
        # İstemciden gelen istekler kabul edilir.
        conn, _ = sock.accept()
        conn_ssl = context.wrap_socket(conn, server_side=True)

        # istemci ile ilgili (kimlik kontrolü, round sorgulama, model indirme ve yükleme gibi)
        # tüm işlemler handle_client fonksiyonunda gerçekleştirilir.
        handle_client(conn_ssl)

        # Hedeflenen doğruluk (accuracy) değerine ulaşıldığı zaman
        # model_update fonksiyonu True değerini döndürür.
        if model_update():
            break

print("--------------------------")
print("FÖS, en son GLOBAL modeli oluşturdu ve tüm işlemler sona erdi.")
