import os
import json
import numpy as np
import pandas as pd
from models.model import FNN_BC, FNN_MC, LSTM_BC, LSTM_MC
from other import info_load, info_update, load_json_file, encrypt_file, decrypt_file, remove_files
from sklearn.model_selection import train_test_split
from sklearn.metrics import precision_score, recall_score, f1_score


# Kimlik kontrolü için kullanılır.
def login_user(user_no, api_key):
    api = load_json_file("apikeys/users.json")
    return api[user_no] == api_key


# GLOBAL_ROUND değerini konsola yazdırmak için kullanılır.
def print_global_round():
    info = info_load()
    print(f" GLOBAL_ROUND = {info['round_num']}")


# İstemcilerle ilgili her türlü işlemin gerçekleştirilmesinde kullanılır.
def handle_client(conn):
    info = info_load()

    try:
        while True:
            data = conn.recv(1024).decode()
            if not data:
                break

            command = data.split()
            if command[0] == "KOMUT":
                # user_no ve api_key kontrolü
                if login_user(command[1], command[2]):
                    # round_num sorgulamasına cevap verilir.
                    if command[3] == "CHECK_ROUND_GET":
                        conn.send(f"ROUND_NUM_GET:{info['round_num']}".encode())

                    # round_num sorgulamasına cevap verilir ve
                    # cevap sonrası istemci yerel modelini gönderir.
                    elif command[3] == "CHECK_ROUND_POST":
                        conn.send(f"ROUND_NUM_POST:{info['round_num']}".encode())

                    # İstemci en son güncel global model dosyasını talep eder.
                    elif command[3] == "GET_MODEL":
                        # Şifrelenmiş global model dosyası istemciye gönderilir.
                        with open(f"{info['global_model_enc_prefix']}", "rb") as f:
                            model_data = f.read()
                            conn.send(model_data)
                        break  # Bu dosyanın gönderiminden sonra döngüden çıkılmalıdır.
                        # Socket bağlantısı finally bloğunda otomatik olarak kapatılır.

                    # İstemci kendi yerel modelinin şifrelenmiş dosyasını gönderir.
                    elif command[3] == "POST_MODEL":
                        # Sunucuya gönderilen şifreli dosya kaydedilir.
                        kaydedilen_dosya = (f"{info['local_models_enc_prefix']}_"
                                            f"{command[1]}_{info['round_num']}.weights.h5")
                        with open(kaydedilen_dosya, "wb") as f:
                            while True:
                                part = conn.recv(1024)
                                if not part:
                                    break
                                f.write(part)

                        print(f" Client {command[1]}, GLOBAL_ROUND = {info['round_num']} için LOCAL modelini gönderdi!")

                        # Belli bir round_num için tüm gönderilen yerel modellerin isimleri bir listede tutulur.
                        info['local_models'].append(kaydedilen_dosya)
                        info_update(info)

                    else:
                        # Önceden tanımlı API komutları dışında bir komut gönderilirse
                        # hata meydana gelir ve bağlantı kesilir.
                        conn.send("ERROR: EKSIK VEYA HATALI KOMUT".encode())

                else:
                    # user_no ve api_key doğru değilse hata meydana gelir ve bağlantı kesilir.
                    conn.send("ERROR: API_KEY VEYA USER_NO HATASI".encode())
                    break
    finally:
        # try bloğunda biten her işlem sonrası bağlantı kesilir.
        conn.close()


# FedAvg algoritmasının uygulanabilmesi için kullanılan fonksiyondur.
def federated_averaging(models):
    weights = [model.get_weights() for model in models]
    new_weights = []

    for weights_list in zip(*weights):
        new_weights.append(np.mean(weights_list, axis=0))

    return new_weights


# Sunucuya gönderilen yerel model dosyalarının önce şifreleri çözülür.
# Ardından FedAvg algoritması ile yerel modeller birleştirilerek
# tek model elde edilir. Daha sonra global model test edilerek,
# doğruluk değerleri hesaplanır. Son olarak elde edilen metrik değerleri
# logs klasöründeki ilgili dosyaya yazdırılır.
def model_update():
    info = info_load()

    local_models = []
    local_enc_models = info['local_models']

    if len(local_enc_models) >= info['users']:
        print("--------------------------")
        print(f" GLOBAL_ROUND = {info['round_num']} için LOCAL modeller birleştiriliyor...")

        for loc_enc in local_enc_models:
            # Şifreli dosyanın çözümlenmesi
            decrypted_file = decrypt_file(loc_enc, f"{info['local_models_prefix']}_temp.weights.h5")

            # FNN
            if info['arc_type'] == 0:
                if info['class_type'] == 0:
                    model = FNN_BC().build()
                else:
                    model = FNN_MC().build()

            # LSTM
            else:
                if info['class_type'] == 0:
                    model = LSTM_BC().build()
                else:
                    model = LSTM_MC().build()

            model.load_weights(decrypted_file)
            local_models.append(model)

        # FedAvg ile local modellerin birleştirilmesi
        averaged_weights = federated_averaging(local_models)

        # Ortalama katsayılarla yeni GLOBAL modelin oluşturulması
        if info['arc_type'] == 0:
            if info['class_type'] == 0:
                global_model = FNN_BC().build()
            else:
                global_model = FNN_MC().build()
        else:
            if info['class_type'] == 0:
                global_model = LSTM_BC().build()
            else:
                global_model = LSTM_MC().build()

        global_model.set_weights(averaged_weights)

        # Buradaki optimizer'ın model evaluate'e bir katkısı yoktur.
        # Keras'ın yapısı böyle olduğu için mecburiyetten bu parametreyi belirtmek zorundayız.
        global_model.compile(optimizer="Adam", loss=info['loss'], metrics=info['metrics'])

        global_model.save_weights(f"{info['global_model_prefix']}")
        encrypt_file(f"{info['global_model_prefix']}", f"{info['global_model_enc_prefix']}")

        # Güncel global model test edilir.
        loss, acc, precision, recall, f1 = model_test(global_model)

        # Sonuçlar logs klasöründeki ilgili dosyaya yazılır.
        logla(info['arc_type'], info['class_type'], info['users'], loss, acc, precision, recall, f1)

        # Hedef doğruluk değeri kontrol edilir.
        # Bu değere eşit veya üstünde bir değer elde edilmişse, federe sistem sonlandırılır.
        # Aksi halde, federe sistem yeni bir tura geçer. round_num değeri 1 arttırılır.
        if acc >= info['hedef_acc']:
            return True

        info['round_num'] += 1
        remove_files('models/local_models')
        info['local_models'] = []
        info_update(info)

        print(f" FÖS, GLOBAL_ROUND = {info['round_num']} için yeni LOCAL modelleri bekliyor...")
        print("--------------------------")

    else:
        return False


# Sunucuda yerel modellerin birleştirilmesi sonrası,
# oluşan güncel global modelin başarısının test edildiği fonksiyondur.
def model_test(model):
    # server_main.json dosyasındaki ayarlar yüklenir.
    info = info_load()

    # CIC-MalMem-2022 veri seti
    df = pd.read_csv(info['csv_file'])
    X = df.iloc[:, 0:-1].values
    y = df.iloc[:, -1].values

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=info['csv_test_size'], stratify=y)

    if info['arc_type'] == 1:
        X_test = X_test.reshape((X_test.shape[0], 1, X_test.shape[1]))

    loss, acc = model.evaluate(X_test, y_test, verbose=info['verbose'], batch_size=1)

    loss = round(loss, 3)
    acc = round(acc, 3)

    # İkili Sınıflandırma (Binary Classification)
    if info['class_type'] == 0:
        zero_division = 0
        average = 'binary'
        y_pred = np.where(model.predict(X_test, verbose=info['verbose']) >= 0.5, 1, 0)

    # Çoklu Sınıflandırma (Multiclass Classification)
    else:
        zero_division = 1
        average = 'weighted'
        y_pred = np.argmax(model.predict(X_test, verbose=0), axis=1)

    precision = round(precision_score(y_test, y_pred, average=average, zero_division=zero_division), 3)
    recall = round(recall_score(y_test, y_pred, average=average, zero_division=zero_division), 3)
    f1 = round(f1_score(y_test, y_pred, average=average, zero_division=zero_division), 3)

    print("--------------------------")
    print(f" GLOBAL_ROUND = {info['round_num']}")
    print(f' Loss: {loss}\n Accuracy: {acc}')
    print(f' Precision: {precision}\n Recall: {recall}\n F1: {f1}')
    print("--------------------------")

    return loss, acc, precision, recall, f1


# Güncel global modelden elde edilen metriklerin
# logs klasöründeki ilgili dosyaya yazılması için kullanılan fonksiyondur.
def logla(arc, cls, users, loss, acc, precision, recall, f1):
    if arc == 0:
        arc = "FNN"
    else:
        arc = "LSTM"

    if cls == 0:
        cls = "Binary"
    else:
        cls = "Multiclass"

    file = f"logs/{arc}_{cls}_{users}.json"

    if not os.path.exists(file):
        nesne = []
    else:
        with open(file, "r") as f:
            nesne = json.load(f)

    nesne.append({"loss": loss, "acc": acc, "precision": precision, "recall": recall, "f1": f1})

    with open(file, "w") as f:
        json.dump(nesne, f, indent=4)
